<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0056)https://mflash.github.io/progswb2/trab/t1-202-hjb7fyhdc/ -->
<html lang="en" data-lt-installed="true"><script data-dapp-detection="">
(function() {
  let alreadyInsertedMetaTag = false

  function __insertDappDetected() {
    if (!alreadyInsertedMetaTag) {
      const meta = document.createElement('meta')
      meta.name = 'dapp-detected'
      document.head.appendChild(meta)
      alreadyInsertedMetaTag = true
    }
  }

  if (window.hasOwnProperty('web3')) {
    // Note a closure can't be used for this var because some sites like
    // www.wnyc.org do a second script execution via eval for some reason.
    window.__disableDappDetectionInsertion = true
    // Likely oldWeb3 is undefined and it has a property only because
    // we defined it. Some sites like wnyc.org are evaling all scripts
    // that exist again, so this is protection against multiple calls.
    if (window.web3 === undefined) {
      return
    }
    __insertDappDetected()
  } else {
    var oldWeb3 = window.web3
    Object.defineProperty(window, 'web3', {
      configurable: true,
      set: function (val) {
        if (!window.__disableDappDetectionInsertion)
          __insertDappDetected()
        oldWeb3 = val
      },
      get: function () {
        if (!window.__disableDappDetectionInsertion)
          __insertDappDetected()
        return oldWeb3
      }
    })
  }
})()</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="http://www.nongnu.org/elyxer/">
<meta name="create-date" content="2020-09-16">
<link rel="stylesheet" href="./Gerador de ASCII Art_files/lyx.css" type="text/css" media="all">
<link rel="stylesheet" href="./Gerador de ASCII Art_files/agate.min.css" type="text/css" media="all">
<script type="text/javascript" src="./Gerador de ASCII Art_files/highlight.pack.js.download"></script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><title>Gerador de ASCII Art</title>
<script type="text/javascript" src="./Gerador de ASCII Art_files/MathJax.js.download">
  //  Load MathJax and get it running
  MathJax.Hub.Config({ jax: ["input/TeX"],
  config: ["MMLorHTML.js"],
  extensions: ["TeX/AMSmath.js","TeX/AMSsymbols.js"],
  "HTML-CSS": { imageFont: null,
      styles: { ".MathJax_Preview": { color: "#000" } } }
  });
</script>
</head>
<body>
<div id="globalWrapper">
<script type="math/tex">
\newcommand{\lyxlock}{}
</script>
<noscript>
<div class="warning">
Warning: <a href="http://www.mathjax.org/">MathJax</a> requires JavaScript to correctly process the mathematics on this page. Please enable JavaScript on your browser.
</div><hr>
</noscript>
<h1 class="title">
Trabalho Prático 1
</h1>
<h1 class="title">
Gerador de<i> ASCII Art</i>
</h1>
<h2 class="Date">
09/2020
</h2>
<h1 class="">
<a class="toc" name="toc--1" target="new">1</a> Introdução
</h1>
<div class="Unindented">
O uso de caracteres da tabela ASCII para produzir desenhos não é uma idéia recente: vem de tempos longínquos, onde os dispositivos de saída eram monitores monocromáticos e impressoras matriciais ou de linha. Mais recentemente, se tornou uma forma de "arte" - daí o termo <i>ASCII</i> <i>Art</i>. Ou seja, imagens criadas exclusivamente com o uso de caracteres da tabela ASCII.
</div>
<div class="Indented">
O objetivo deste trabalho é explorar os conceitos de programação C vistos em aula, criando um programa capaz de produzir a representação de uma imagem qualquer em ASCII. A saída do programa será na forma de um arquivo HTML, que poderá ser visualizado no browser. Se você estava em outro planeta nos últimos anos e nunca viu isso, há diversos serviços na rede que fazem esse tipo de conversão:
</div>
<ul>
<li>
<a class="FlexURL" href="http://www.text-image.com/" target="new">http://www.text-image.com/</a>
</li>
<li>
<a class="FlexURL" href="http://picascii.com/" target="new">http://picascii.com/</a>
</li>
<li>
<a class="FlexURL" href="http://lunatic.no/ol/img2aschtml.php" target="new">http://lunatic.no/ol/img2aschtml.php</a>
</li>

</ul>
<div class="Unindented">
O resultado pode ser visto na figura 1:
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figura-1" target="new"> </a><div class="figure">
<div class="center">
<img class="embedded" src="./Gerador de ASCII Art_files/flower.jpg" alt="figure flower.jpg" style="max-width: 343px; max-height: 257px;">
<img class="embedded" src="./Gerador de ASCII Art_files/flower_ascii.jpg" alt="figure flower_ascii.jpg" style="max-width: 343px; max-height: 257px;">

</div>
<div class="caption">
Figura 1 Imagem original (esq.) e convertida para <i>ASCII Art</i> (dir.)
</div>

</div>

</div>

</div>
<h1 class="">
<a class="toc" name="toc--2" target="new">2</a> Funcionamento
</h1>
<div class="Unindented">
Ao ser iniciado, o programa deve solicitar o nome de um arquivo de imagem e carregá-lo (ou obter o nome por parâmetros de linha de comando).
</div>
<div class="Indented">
Para ler as imagens utilizaremos uma biblioteca simples (integrada no projeto de exemplo) denominada <i>SOIL</i>. Veja detalhes na seção 2.1. Após a leitura, a imagem deve ser processada e gerado o arquivo de saída em HTML.
</div>
<div class="Indented">
Parte do objetivo deste trabalho é a criação de um algoritmo que produza um resultado interessante. Uma possível estratégia é a seguinte:
</div>
<ol>
<li>
Obter do usuário o <b>nome</b> <b>da</b> <b>imagem</b> a ser carregada, e o <b>fator</b> <b>de</b> <b>redução</b> <b>desejado</b>. Por exemplo, o fator 50% utilizará apenas metade dos pixels originais na saída. Esse fator é usado para calcular o tamanho dos blocos de pixels (ver passo 5).
</li>
<li>
Ler a imagem colorida, onde cada pixel (ponto da imagem) é representado em RGB (ver seção 2.1).
</li>
<li>
Converter a imagem para tons de cinza, isto é, eliminar a cor e considerar que qualquer pixel pode ser representado por um único número inteiro, representando variações de preto (0) a branco (255).
</li>
<li>
Associar cada caractere a um tom de cinza específico. Você pode pesquisar nos sites indicados (ou outros) para ver como isso normalmente é realizado. Mas a idéia básica é que caracteres que ocupam mais espaço visualmente correspondam a cores mais claras (considerando um fundo preto). Por exemplo, "@" é mais "claro" do que "."
</li>
<li>
De acordo com as proporções das letras (que não são quadradas), agrupar os pixels da imagem em blocos retangulares (por exemplo, 4 x 5). Cada bloco irá se transformar em um único caractere na saída. Isso é necessário, pois as imagens normalmente são muito grandes para fazer uma correspondência 1:1.
</li>
<li>
Calcular o tom de cinza médio de cada bloco (por exemplo, fazendo a média de todos os pixels do bloco).
</li>
<li>
Para cada bloco de pixels, escolher e gerar um caractere na saída, cujo tom de cinza é uma boa aproximação para a média do bloco.
</li>

</ol>
<div class="Unindented">
As próximas seções dão algumas dicas de como realizar certas etapas.
</div>
<h2 class="">
<a class="toc" name="toc--2.1" target="new">2.1</a> Leitura da imagem
</h2>
<div class="Unindented">
Uma imagem é geralmente representada por uma matriz de pontos (<i>pixels</i>)<i> </i>onde cada cor é definida por 3 componentes: vermelho (R), verde (G) e azul (B). Cada uma dessas componentes usualmente é codificada em <b>um byte</b>, o que produz <b>3 bytes por <i>pixel</i></b> (24 bits) - ou seja, 16 milhões de possíveis cores. Em outras palavras, as intensidades (R, G, B) variam de 0 a 255, onde 0 é escuro e 255 é claro.
</div>
<div class="Indented">
Veja abaixo como diversas cores são representadas nesse formato - cada cor está expressa pelas componentes RGB em hexadecimal.
</div>
<div class="Indented">
<div class="center">
<img class="embedded" src="./Gerador de ASCII Art_files/hex-colors.jpg" alt="figure hex-colors.jpg" style="max-width: 300px; max-height: 300px;">
<img class="embedded" src="./Gerador de ASCII Art_files/rgbcolors.jpg" alt="figure rgbcolors.jpg" style="max-width: 712px; max-height: 271px;">

</div>

</div>
<div class="Indented">
O código fornecido define duas <i>structs</i>: uma para representar um <i>pixel</i> e outra para representar a imagem inteira. Após a leitura da imagem, os <i>pixels</i> estarão disponíveis no vetor <i>pic.img</i>
</div>
<div class="Indented">
<pre class="listing"><code class="cpp hljs "><span class="hljs-comment">// Um pixel RGB (24 bits)</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> r, g, b;
} RGB;

<span class="hljs-comment">// Uma imagem RGB</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-keyword">int</span> width, height;
    RGB* img;            <span class="hljs-comment">// vetor de pixels</span>
} Img;

<span class="hljs-comment">// A imagem</span>
Img pic;

<span class="hljs-comment">// Cada pixel está armazenado em pic.img[i], onde i é o índice do pixel.</span>
<span class="hljs-comment">// Exemplo: acessando os dois primeiros pixels</span>
RGB aux1 = pic.img[<span class="hljs-number">0</span>];
RGB aux2 = pic.img[<span class="hljs-number">1</span>];
...
</code>
</pre>

</div>
<h2 class="">
<a class="toc" name="toc--2.2" target="new">2.2</a> Conversão para tons de cinza
</h2>
<div class="Unindented">
O processo de conversão de uma imagem para tons de cinza pode ser feito com o algoritmo descrito abaixo. A idéia é simplicar a imagem, deixando as três componentes R,G e B de cada ponto iguais entre si - equivale a "tirar a cor" da imagem. O valor a ser colocado nestes 3 componentes deverá ser igual à <b>intensidade</b> <b>da</b> <b>cor</b>, dada pela fórmula:
</div>
<div class="Indented">
<span class="MathJax_Preview">
<script type="math/tex;mode=display">

I=0.3R+0.59G+0.11B

</script>

</span>

</div>
<div class="Indented">
<pre class="listing"><code class="cpp hljs ">Para cada ponto (x,y) da imagem:
    Obtem a cor <span class="hljs-keyword">do</span> pixel (r,g,b)
    <span class="hljs-comment">// calcula o equivalente cinza da cor</span>
    i = (<span class="hljs-number">0.3</span> * r + <span class="hljs-number">0.59</span> * g + <span class="hljs-number">0.11</span> * b)
    <span class="hljs-comment">// armazena o cinza no pixel</span>
    EscreveCor(x,y,i,i,i) <span class="hljs-preprocessor"># x,y,r,g,b</span>
</code>
</pre>

</div>
<h2 class="">
<a class="toc" name="toc--2.3" target="new">2.3</a> Geração do HTML de saída
</h2>
<div class="Unindented">
Para gerar o código HTML resultante, é preciso escrever determinadas <i>tags</i> no arquivo de saída, de forma que o browser saiba como interpretar os caracteres:
</div>
<div class="Indented">
<pre class="listing"><code class="cpp hljs ">&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body style=<span class="hljs-string">"background: black;"</span> leftmargin=<span class="hljs-number">0</span> topmargin=<span class="hljs-number">0</span>&gt; 
&lt;style&gt; 
   pre  {
          color: white;
    font-family: Courier;
      font-size: <span class="hljs-number">8</span>px;
   }
&lt;/style&gt;
</code>
</pre>

</div>
<div class="Indented">
Esse trecho define que o fundo será <b>preto</b>, enquanto os caracteres serão <b>brancos</b>, para o estilo pré-formatado (<i>tag</i> <i>PRE</i>) e com uma fonte bem pequena (<i>8px</i>). A partir deste ponto, a imagem deve aparecer dentro de um bloco <i>&lt;pre&gt;...&lt;/pre&gt;</i>:
</div>
<div class="Indented">
<pre class="listing"><code class="cpp hljs ">&lt;pre&gt;
... caracteres da imagem - linha <span class="hljs-number">1</span> ...
... caracteres da imagem - linha <span class="hljs-number">2</span> ...
...
&lt;/pre&gt;
</code>
</pre>

</div>
<div class="Indented">
Finalmente, deve-se fechar o corpo da página e o HTML em si:
</div>
<div class="Indented">
<pre class="listing"><code class="cpp hljs ">&lt;/body&gt;
&lt;/html&gt;
</code>
</pre>

</div>
<h1 class="">
<a class="toc" name="toc--3" target="new">3</a> Código base e imagens de teste
</h1>
<div class="Unindented">
O arquivo <a class="URL" href="https://mflash.github.io/progswb2/trab/t1-202-hjb7fyhdc/loader-t1-20202.zip" target="new">loader-t1-20202.zip</a> contém o projeto completo para a implementação do trabalho. Esse código já realiza a leitura de uma imagem qualquer de 24 bits. O projeto pode ser compilado no Windows, Linux ou macOS, seguindo as instruções abaixo.
</div>
<div class="Indented">
Para a compilação no Linux, é necessário ter instalado os pacotes de desenvolvimento da biblioteca OpenGL. Para Ubuntu, Mint, Debian e derivados, instale com:
</div>
<div class="Indented">
<pre class="listing"><code class="bash hljs ">sudo apt-get install freeglut3-dev
</code>
</pre>

</div>
<div class="Indented">
Para a compilação no Windows ou no macOS, não é necessário instalar mais nada - o compilador já vem com as bibliotecas necessárias.
</div>
<h2 class="">
<a class="toc" name="toc--3.1" target="new">3.1</a> Visual Studio Code
</h2>
<div class="Unindented">
Se você estiver utilizando o Visual Studio Code, basta descompactar o zip e abrir a pasta.
</div>
<div class="Indented">
Para <b>compilar</b>: use Ctrl+Shift+B (<b>⌘</b>+Shift+B no macOS).
</div>
<div class="Indented">
Para <b>executar</b>, use F5 para usar o <i>debugger</i> ou Ctrl+F5 para executar sem o <i>debugger</i>.
</div>
<h2 class="">
<a class="toc" name="toc--3.2" target="new">3.2</a> Outros ambientes ou terminal
</h2>
<div class="Unindented">
Caso esteja usando outro ambiente de desenvolvimento, fornecemos um <i>Makefile</i> para Linux e macOS, e outro para Windows (<i>Makefile.mk</i>).
</div>
<div class="Indented">
Dessa forma, para compilar no Linux ou macOS, basta digitar:
</div>
<div class="Indented">
<pre class="listing"><code class="bash hljs ">make
</code>
</pre>

</div>
<div class="Indented">
Se estiver utilizando o Windows, o comando é similar:
</div>
<div class="Indented">
<pre class="listing"><code class="bash hljs ">mingw32-make -f Makefile.mk
</code>
</pre>

</div>
<div class="Indented">
Alternativamente, você também pode utilizar o <i>CMake</i> (<i>Cross Platform Make</i>) para compilar pelo terminal. Para tanto, crie um diretório <i>build</i> embaixo do diretório do projeto e faça:
</div>
<div class="Indented">
<pre class="listing"><code class="bash hljs python">cd build
cmake ..
make -j  <span class="hljs-comment"># ou mingw32-make -j no Windows</span>
</code>
</pre>

</div>
<h1 class="">
<a class="toc" name="toc--4" target="new">4</a> Avaliação
</h1>
<div class="Unindented">
Leia com atenção os critérios de avaliação:
</div>
<ul>
<li>
Pontuação:<ul>
<li>
Conversão para cinza: 2 pontos
</li>
<li>
Obtenção do cinza médio do bloco: 2,5 pontos
</li>
<li>
Manutenção da proporção da "imagem" resultante: 2,5 pontos
</li>
<li>
Geração da saída em HTML: 2 pontos
</li>
<li>
Escolha do conjunto de caracteres para a saída: 1 ponto
</li>

</ul>

</li>
<li>
Os trabalhos são <b>em duplas ou individuais</b>. A pasta do projeto deve ser compactada em um arquivo .zip e este deve ser submetido pelo <i>Moodle</i> até a data e hora especificadas.
</li>
<li>
Não envie .rar, .7z, .tar.gz - apenas <b>.zip.</b>
</li>
<li>
O código deve estar identado corretamente (qualquer editor decente<i> <b></b></i>faz <b>isso</b> <b>automaticamente</b>).
</li>
<li>
<b>A cópia parcial ou completa do trabalho terá como conseqüência a atribuição de nota ZERO ao trabalho dos alunos envolvidos. A verificação de cópias é feita inclusive entre turmas.</b>
</li>
<li>
<b>A cópia de código ou algoritmos existentes da Internet também não é permitida</b>. Se alguma idéia encontrada na rede for utilizada na implementação, sua descrição e referência deve constar no artigo.
</li>

</ul>

<hr class="footer">
<div class="footer" id="generated-by">
Document generated by <a href="http://elyxer.nongnu.org/">eLyXer 1.2.5 (2013-03-10)</a> on <span class="create-date">2020-09-16T15:16:24.731807</span>
</div>
</div>


</body></html>